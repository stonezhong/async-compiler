# Compare async compiler to ES7 async function side by side

** conclusion: it appears async compiler produces the same result comparing to ES7's async function. In some cases, ES7's await is broken (see `access object field -- case 2`). **

For the ES7 test, I am using the following config:
```
{
  "presets": ["es2015"],
  "plugins": ["syntax-async-functions","transform-regenerator"]
}
```

Here are test cases:

## Waiting for a promise
result: both prints 'Hello world', with async compiler, code looks cleaner since you do not need to put an await there.

with ES7-async function
```
"use strict";
require('babel-polyfill');

var a = Promise.resolve('Hello world');
async function foo() {
  console.log(await a);
}

foo();
```

with async compiler
```
var AsyncTool = require('async-compiler-runtime');

var a = Promise.resolve('Hello world');
/** @async **/ function foo() {
  console.log(a);
}

foo();
```

## Wait for a promise returned form a function
result: both works.

with ES7-async function
```
"use strict";
require('babel-polyfill');

function bar() {
  return Promise.resolve('Hello world');
}

async function foo() {
  console.log(await bar());
}

foo();
```

with async compiler
```
var AsyncTool = require('async-compiler-runtime');

function bar() {
  return Promise.resolve('Hello world');
}

/** @async **/ function foo() {
  console.log(bar());
}

foo();
```

## access object field -- case 1
result: both works, code with async compiler seems cleaner.

with ES7-async function
```
"use strict";
require('babel-polyfill');

var a = Promise.resolve({
  title: 'SDE'
});

var b = Promise.resolve({
  title: Promise.resolve('SDE')
});

async function foo() {
  console.log((await a).title);
  console.log(await (await a).title);
}

foo();
```

with async compiler
```
var AsyncTool = require('async-compiler-runtime');

var a = Promise.resolve({
  title: 'SDE'
});

var b = Promise.resolve({
  title: Promise.resolve('SDE')
});

/** @async **/ function foo() {
  console.log(a.title);
  console.log(b.title);
}

foo();
```

## access object field -- case 2

**result: code generated by babel is broken for ES7, it prints undefined instead of SDE, async compiler works perfect in this case**

with ES7-async
```
"use strict";
require('babel-polyfill');

var a = Promise.resolve({
  title: 'SDE'
});

var b = Promise.resolve({
  title: Promise.resolve('SDE')
});

var field = Promise.resolve('title');

async function foo() {
  console.log((await a)[await field]);
  console.log(await (await a)[await field]);
}

foo();
```

with async compiler
```
var AsyncTool = require('async-compiler-runtime');

var a = Promise.resolve({
  title: 'SDE'
});

var b = Promise.resolve({
  title: Promise.resolve('SDE')
});

var field = Promise.resolve('title');

/** @async **/ function foo() {
  console.log(a[field]);
  console.log(b[field]);
}

foo();
```

## calling a promised function

result: both produce the right output

with ES7-async
```
"use strict";
require('babel-polyfill');

var funny = Promise.resolve(function() {
  console.log('hello');
});

async function foo() {
  (await funny)();
}

foo();
```

with async compiler
```
var AsyncTool = require('async-compiler-runtime');

var funny = Promise.resolve(function() {
  console.log('hello');
});

/** @async **/ function foo() {
  funny();
}

foo();
```
